# Developer Guide

Welcome to the AgreedTime developer documentation. This guide covers the project architecture, code standards, and contribution workflows.

---

## 1. Architecture & Patterns

This project is built with **Astro** (Static Shell) and **React** (Interactive Islands).

### Core Concept: Astro Islands
We follow the "HTML First" philosophy. The page shell (`Layout`, `Header`, `Text`) is static HTML generated by Astro. Only interactive widgets (like the Form and Calendar) are hydrated as React components using `client:load`.

### File Structure
*   **`src/pages/`**: File-system routing. `new.astro` corresponds to `/new`.
*   **`src/components/`**: React components and Astro snippets.
    *   `CreateEventForm.tsx`: The main "Island" controller.
    *   `TimeSlotSelector.tsx`: The core calendar widget logic.
*   **`src/utils/`**: Pure helper functions (e.g., date manipulation using `date-fns`).

### Key Logic: TimeSlotSelector
*   **State**: Selected slots are stored as a `Set<string>` of **UTC ISO Strings** (`2025-12-05T09:00:00Z`).
*   **Layout**: Uses a specific "Sticky Column" layout where the time labels are in a separate `div` from the scrollable date grid.
*   **Mobile**: Implements custom "Long Press" logic for drag-selection on touch devices.

---

## 2. Code Style & Standards

### Tech Stack
*   **Framework**: Astro + React 19
*   **Styling**: Tailwind CSS
*   **Language**: TypeScript (Strict mode)
*   **Date Handling**: `date-fns` (Always use UTC for storage, Local for display)

### Best Practices
*   **Functional Components**: Use React Hooks (`useState`, `useMemo`, `useCallback`).
*   **Props Interface**: Always define a TypeScript interface for component props.
*   **Tailwind**: Use utility classes directly. For complex logic, use conditional strings (template literals).
*   **Accessibility**: Ensure all interactive elements have `role`, `aria-label`, and keyboard support (`onKeyDown`).

---

## 3. Git Commit Convention

We follow the **[Conventional Commits](https://www.conventionalcommits.org/)** specification.

### Format
`type(scope): subject`

### Types
*   `feat`: New feature
*   `fix`: Bug fix
*   `docs`: Documentation only
*   `style`: Formatting (whitespace, semi-colons)
*   `refactor`: Code change that neither fixes a bug nor adds a feature
*   `chore`: Build process, deps, or auxiliary tools

### Example
*   `feat(calendar): add sticky time column`
*   `fix(mobile): resolve long-press selection bug`

---

## 4. Development Workflow

1.  **Start Dev Server**: `npm run dev`
2.  **Build for Production**: `npm run build`
3.  **Preview Build**: `npm run preview`

---

## 5. Event Access and Management Strategy

This section outlines the planned approach for managing access to event pages, balancing ease-of-use with necessary security and privacy considerations, especially before a full user authentication system is in place.

### 5.1 User Flows & Page Roles

*   **Create Event Page (`/new`)**:
    *   Allows users (organizers) to define event details and availability.
    *   Upon successful creation, an event ID (`:id`) is generated.
*   **Guest Submission Page (`/event/:id`)**:
    *   Accessible via a public invitation link.
    *   Allows attendees to submit their available time slots and optional comments.
*   **Event Result Page (`/event/:id/result`)**:
    *   Displays aggregated availability, best time recommendations, and participant responses.
    *   **Core Vision**: To evolve into a heatmap visualization of time slot intersections. Initially, it will provide a list-based summary.

### 5.2 Access Control Mechanism (Hybrid Model)

To provide a balance between frictionless anonymous usage and future member-based management, a hybrid access control model will be implemented:

1.  **Public Event ID (`:id`)**:
    *   Generated for every event.
    *   Used for public-facing links, primarily the Guest Submission Page (`/event/:id`).
    *   The Event Result Page (`/event/:id/result`) may or may not be publicly accessible, depending on the organizer's privacy preference (defaulting to publicly viewable results for ease of sharing).

2.  **`adminToken` (Long Secret String)**:
    *   A unique, long, and unguessable token (e.g., UUID) generated upon event creation.
    *   **Purpose**: Provides direct, secret-link-based access to event management features (e.g., `event/:id/manage?token=adminToken`) without requiring a login. This is primarily for **anonymous organizers**.
    *   **Usage**: The organizer saves this link or its token to re-access full management capabilities.

3.  **`secureCode` (Short, 6-Digit Code)**:
    *   A short, memorable alphanumeric code generated upon event creation.
    *   **Purpose**: Serves as a recovery or "claiming" mechanism, primarily for **anonymous organizers**.
    *   **Usage**:
        *   **Recovery**: If an organizer loses their `adminToken` link, they can use the Event ID and `secureCode` to regain access to management features (e.g., via a "Lookup" page).
        *   **Claiming (Future)**: When a user registers an account, they can "claim" ownership of an existing event by providing its Event ID and `secureCode`, associating it with their user account.

### 5.3 Initial Implementation & Future Enhancements

*   **Current State**: Events are created anonymously.
*   **Initial Display on Event Creation Success**: The system will present both the public Guest Link and the Admin Link (containing the `adminToken`). The `secureCode` will also be displayed with instructions to save it.
*   **Future - Member Integration**: Once a user authentication system is in place, if an event is created by a logged-in member, the `adminToken` and `secureCode` will still be generated but may not be explicitly shown to the user (as their account login provides management access). Members will manage events from a personalized dashboard.
*   **Future - "Claim Event" Feature**: A dedicated interface for members to link existing events to their accounts using the `secureCode`.