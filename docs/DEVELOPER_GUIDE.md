# Developer Guide

Welcome to the AgreedTime developer documentation. This guide covers the project architecture, code standards, and contribution workflows.

---

## 1. Architecture & Patterns

This project is built with **Astro** (Static Shell) and **React** (Interactive Islands).

### Core Concept: Astro Islands
We follow the "HTML First" philosophy. The page shell (`Layout`, `Header`, `Text`) is static HTML generated by Astro. Only interactive widgets (like the Form and Calendar) are hydrated as React components using `client:load`.

### File Structure
*   **`src/pages/`**: File-system routing. `new.astro` corresponds to `/new`.
*   **`src/components/`**: React components and Astro snippets.
    *   `CreateEventForm.tsx`: The main "Island" controller.
    *   `TimeGrid.tsx`: Core component for rendering the generic calendar grid structure (weeks, days, time labels).
    *   `TimeSlotCell.tsx`: Renders an individual time slot cell, handling mode-specific (selection/heatmap) visual representation and local interaction.
    *   `TimeSlotSelector.tsx`: Component dedicated to handling time slot selection logic and state, utilizing `TimeGrid` and `TimeSlotCell`.
    *   `Heatmap.tsx`: Component dedicated to handling heatmap data transformation and display logic, utilizing `TimeGrid` and `TimeSlotCell`.
*   **`src/utils/`**: Pure helper functions (e.g., date manipulation using `date-fns`).

### Key Logic: Time Slot Components (TimeGrid, TimeSlotCell, TimeSlotSelector, Heatmap)
The core calendar functionality is now split across several specialized components to reduce redundancy and improve modularity:
*   **`TimeGrid.tsx`**: Provides the structural layout for the calendar grid. It generates rows (days) and columns (time slots) and handles overall grid navigation (e.g., week scrolling). It receives `renderCell` and `renderDateHeader` props to allow parent components to customize cell and header rendering.
*   **`TimeSlotCell.tsx`**: This component renders a single interactive cell within the `TimeGrid`. It encapsulates the mode-specific (selection or heatmap) visual styling, content display (e.g., vote count), tooltips, and local event handling.
*   **`TimeSlotSelector.tsx`**: This component manages the state and logic for selecting time slots. It acts as a wrapper around `TimeGrid`, passing `mode="select"` to `TimeSlotCell` via `TimeGrid`'s `renderCell` prop, and handles drag-to-select interactions. Selected slots are stored as a `Set<string>` of **UTC ISO Strings** (`YYYY-MM-DD_HH:MM-HH:MM`).
*   **`Heatmap.tsx`**: This component handles the data transformation and display of availability heatmaps. It wraps `TimeGrid`, processes raw event response data into `heatmapData`, and passes `mode="heatmap"` to `TimeSlotCell` via `TimeGrid`'s `renderCell` prop. It also calculates minimum/maximum date/time ranges for `TimeGrid`.

---

## 2. Code Style & Standards

### Tech Stack
*   **Framework**: Astro + React 19
*   **Styling**: Tailwind CSS
*   **Language**: TypeScript (Strict mode)
*   **Date Handling**: `date-fns` (Always use UTC for storage, Local for display)

### Best Practices
*   **Functional Components**: Use React Hooks (`useState`, `useMemo`, `useCallback`).
*   **Props Interface**: Always define a TypeScript interface for component props.
*   **Tailwind**: Use utility classes directly. For complex logic, use conditional strings (template literals).
*   **Accessibility**: Ensure all interactive elements have `role`, `aria-label`, and keyboard support (`onKeyDown`).

---

## 3. Git Commit Convention

We follow the **[Conventional Commits](https://www.conventionalcommits.org/)** specification.

### Format
`type(scope): subject`

### Types
*   `feat`: New feature
*   `fix`: Bug fix
*   `docs`: Documentation only
*   `style`: Formatting (whitespace, semi-colons)
*   `refactor`: Code change that neither fixes a bug nor adds a feature
*   `chore`: Build process, deps, or auxiliary tools

### Example
*   `feat(calendar): add sticky time column`
*   `fix(mobile): resolve long-press selection bug`

---

## 4. Development Workflow

1.  **Start Dev Server**: `npm run dev`
2.  **Build for Production**: `npm run build`
3.  **Preview Build**: `npm run preview`

---

## 5. Event Access and Management Strategy

This section outlines the planned approach for managing access to event pages, balancing ease-of-use with necessary security and privacy considerations, especially before a full user authentication system is in place.

### 5.1 User Flows & Page Roles

*   **Create Event Page (`/new`)**:
    *   Allows users (organizers) to define event details and availability.
    *   Upon successful creation, an event ID (`:id`) is generated.
*   **Guest Submission Page (`/event/:id`)**:
    *   Accessible via a public invitation link.
    *   Allows attendees to submit their available time slots and optional comments.
*   **Event Result Page (`/event/:id/result`)**:
    *   Displays aggregated availability, best time recommendations, and participant responses.
    *   **Core Vision**: To evolve into a heatmap visualization of time slot intersections. Initially, it will provide a list-based summary.

### 5.2 Access Control Mechanism (Hybrid Model)

To provide a balance between frictionless anonymous usage and future member-based management, a hybrid access control model will be implemented.

#### 5.2.1 Public Event ID (`:id`)
*   Generated for every event.
*   Used for public-facing links, primarily the Guest Submission Page (`/event/:id`).
*   The Event Result Page (`/event/:id/result`) may or may not be publicly accessible, depending on the organizer's privacy preference. Defaulting to publicly viewable results for ease of sharing is common, but private access will be supported via the management flows.

#### 5.2.2 `adminToken` (Long Secret String)
*   A unique, long, and unguessable token (e.g., UUID) generated upon event creation.
*   **Purpose**: Provides direct, secret-link-based access to event management features (e.g., `/event/:id/manage?token=adminToken`) without requiring a login. This is primarily for **anonymous organizers**.
*   **Best Practice**: This "Capability URL" design is a standard and effective pattern for frictionless access in stateless/anonymous applications (e.g., Doodle, Rallly).
*   **Security**: Relies on the secrecy of the token. Token must be sufficiently long and random. Transport via HTTPS is mandatory.
*   **Usage**: The organizer saves this link or its token to re-access full management capabilities. This link provides management rights.

#### 5.2.3 `secureCode` (Short, 6-Digit Code)
*   A short, memorable alphanumeric code generated upon event creation.
*   **Purpose**: Serves as a recovery or "claiming" mechanism, primarily for **anonymous organizers**.
*   **Validation**: `secureCode` alone is insufficient; it must be combined with the `eventId` for validation (`ID + Code` pattern).
*   **Best Practice**: `secureCode` should never be exposed in the URL. It must be entered manually into a dedicated input field or modal.
*   **Storage (Future Backend)**: When stored in a database, `secureCode` (like any password) must be salted and hashed.
*   **Usage**: If an organizer loses their `adminToken` link, they can use the `eventId` and `secureCode` to regain access to management features (e.g., via a "Lookup" page or directly on the event page).

### 5.3 User Experience Flows & Implementation Details

*   **Event Creation Success Screen (`/new` post-submit)**:
    *   Displays the public Guest Link (for participants to respond).
    *   Displays the Admin Link (containing the `adminToken`), masked from direct view with a "Copy Admin Link" button for enhanced security against shoulder-surfing. A clear warning against sharing this link is provided.
    *   Displays the `secureCode`, initially masked (e.g., `******`) with a toggle to reveal. The recovery instruction is context-driven, guiding users to use the code directly on their event page for admin access.
    *   A "Go to Event Results" button navigates to the `event/:id/result` page.

*   **Result Link Revelation**:
    *   The Result Link (`/event/:id/result`) is generally **not actively exposed on the event creation success screen** to avoid overwhelming the user or causing confusion about which link to share.
    *   **Recommended Revelation Points**:
        1.  **Admin/Manage Page (Future)**: The primary place for the organizer to retrieve and share the Result Link, especially for publicly shared results.
        2.  **Result Page Itself**: A "Share Results" button on the `event/:id/result` page itself allows anyone (organizer or participant) to copy the Result Link. This is a common and intuitive practice.

*   **Admin Link Invalid/Expired Handling (Graceful Degradation - Future Backend)**:
    *   If a user accesses `/event/:id/manage?token=invalid-token`, instead of showing an error, the system will redirect them to the public Result Page (`/event/:id/result`).
    *   A prominent banner message on the Result Page should then inform the user: *"The admin link you used is invalid or expired. You are viewing the public results instead."* This provides a user-friendly fallback.

*   **Frontend Organizer Identification (Cookie/LocalStorage - Immediate Future)**:
    *   To improve convenience for the organizer, upon successful event creation (or successful `adminToken`/`secureCode` validation), a flag (`agreed_time_admin_${eventId}`) containing the `adminToken` will be stored in the browser's LocalStorage or a secure Cookie.
    *   This allows the same browser to automatically identify as the event's organizer for that `eventId` in subsequent visits, providing management capabilities without needing to re-enter the token. This offers a "sticky session" for the owner on a specific browser.

### 5.4 Future Enhancements

*   **Member Integration**: Once a user authentication system is in place, if an event is created by a logged-in member, the `adminToken` and `secureCode` will still be generated but may not be explicitly shown to the user (as their account login provides management access). Members will manage events from a personalized dashboard.
*   **"Claim Event" Feature**: A dedicated interface for members to link existing events to their accounts using the `secureCode`.
*   **Backend API**: Implementation of actual API endpoints for event creation, response submission, and result retrieval, replacing current mock data.
*   **Heatmap Visualization**: Enhance the Result Page to graphically display availability intersections.
*   **Edit Participant Response**: Allow participants to modify their previously submitted time slots.
*   **Event Expiry/Deadline**: Option for organizers to set a deadline for submissions.
*   **Social Sharing Buttons**: Integrate direct share options for Guest Link and (public) Result Link.
*   **Email Reminders**: Option to send links/updates via email.

---

## 6. Frontend UI/UX Details

This section documents the visual and interactive design choices made during development.

### 6.1 Header and Brand Identity

*   **Fixed Header**: A responsive, fixed header (`Layout.astro`) is present across all pages for consistent navigation and branding.
*   **Logo Display**: The `agreed-time-logo.svg` is used as the primary brand identifier.
    *   **Header**: The icon is paired with the text "AgreedTime" (`<span class="font-sans font-bold text-ink">AgreedTime</span>`) to ensure clear brand visibility. The spacing between the icon and text (`gap-0`) is set for a tight, cohesive lockup.
    *   **Favicon**: The `agreed-time-logo.svg` itself is directly used as the favicon, ensuring brand consistency in browser tabs. The redundant `favicon.svg` file has been removed.
    *   **Homepage Hero**: The landing page's hero section prominently displays only the large graphic logo (`agreed-time-logo.svg`) without additional text, maintaining a minimalist and "airy" aesthetic.
*   **Brand Typography**: The primary brand typeface for text elements like "AgreedTime" is set to `font-sans` (Zen Kaku Gothic New) for a modern and digital-native feel, complementing the geometric icon. Serif fonts are used for general headings, and mono fonts for technical/time displays.

### 6.2 Visual Theme (Fujifilm-Inspired Palette)

The application's color palette is carefully crafted to evoke a Fujifilm-inspired aesthetic, characterized by cool, cyanic tones and subtle contrasts.

*   **`frontend/tailwind.config.mjs` Colors**:
    *   `paper`: `#F4F8FA` (Soft, low-saturation blue-grey for main background, reducing visual strain).
    *   `ink`: `#155E75` (Deep cyan-tinted grey for primary text, providing rich contrast).
    *   `film-accent`: `#0891B2` (Vibrant Cyan 600 for primary interactive elements, buttons, selected states).
    *   `film-accent-hover`: `#0E7490` (Darker Cyan 700 for hover states).
    *   `film-border`: `#d4e8ed` (Light, cool grey for borders, matching the logo's outer stroke).
    *   `film-light`: `#FFFFFF` (Pure white for elements like input backgrounds and card interiors, creating layered depth).
*   **Consistency**: All UI components, including `TimeSlotSelector` (selected slot color) and `EventResultView`, now automatically utilize this palette, ensuring a unified visual experience.

### 6.3 Event Result Page Enhancements

*   **Empty State Handling**: `EventResultView.tsx` now conditionally renders a user-friendly empty state when no responses have been submitted. This includes a clear message ("No responses yet!"), an illustrative icon, and a call to action. For admins, a "Go to Guest Link" button is provided.
*   **Share Results Button**: A prominent "Share Results" button is available on the Result Page, allowing any viewer to easily copy the current page's URL to their clipboard.
*   **Admin Action Buttons**: For identified event administrators (via LocalStorage token), "Finalize" and "Delete" action buttons are displayed. These are currently simulated with alerts for demonstration purposes.

---

## 7. Heatmap Visualization (Implemented)

The Result Page now features a graphical heatmap visualization of participant availability, leveraging the new modular component architecture.

*   **`Heatmap.tsx`**: This is the top-level component for heatmap display. It's responsible for:
    *   Aggregating raw participant responses (from `EventResultView.tsx`) into `heatmapData`.
    *   Calculating the overall minimum/maximum date and time ranges from the available data.
    *   Rendering the `TimeGrid` component, and providing a `renderCell` prop that configures `TimeSlotCell` for `mode="heatmap"`.
*   **`TimeGrid.tsx`**: Provides the underlying calendar grid structure, navigation, and default header rendering.
*   **`TimeSlotCell.tsx`**: In `"heatmap"` mode, it renders each time slot cell with:
    *   A background color intensity based on the ratio of available participants for that slot (`count / totalParticipants`). A non-linear scaling (`Math.pow(ratio, 0.6)`) is applied for smoother and more perceptually distinct gradients.
    *   A numerical display of the `count` of available participants.
    *   A hover tooltip detailing which participants are available for that specific slot.
    *   All interactive selection features (click, drag) are disabled.
*   **Reusability**: By using `TimeGrid` and `TimeSlotCell`, the heatmap visualization benefits from the same robust grid layout and cell-level logic as the `TimeSlotSelector`, ensuring consistency and minimizing code duplication.

---

## 8. Data Layer & Services

To prepare for future backend integration and maintain a clean separation of concerns, all data fetching and manipulation logic has been centralized.

### 8.1 Event Service (`src/services/eventService.ts`)
*   **Purpose**: Acts as the single source of truth for data operations. Components (like `EventGuestForm`, `EventResultView`) call methods on `eventService` rather than managing data fetching internally.
*   **Methods**:
    *   `getEvent(id)`: Retrieves event details.
    *   `createEvent(...)`: Generates a new event with a unique ID and admin tokens.
    *   `submitResponse(...)`: Saves a guest's availability.
    *   `getEventResults(id)`: Retrieves aggregated results for an event.

### 8.2 Mock Data Strategy (Current Phase)
*   **In-Memory Store**: Currently, the service uses a simple JavaScript object (`eventsStore`, `responsesStore`) to store data during the session.
*   **Persistence Limitation**: Because data is stored in memory, **refreshing the page (or hot-reloading) will clear all created events and responses**. This is expected behavior for the current prototype phase.
*   **Transition Plan**: When the backend is ready, we will only need to update `eventService.ts` to make real API calls (e.g., using `fetch` or `axios`). The UI components will remain largely unchanged.

### 8.3 Feature Deferral
*   **Edit/Update**: Features like editing an event or modifying a guest response are intentionally deferred. These require robust authentication and state synchronization that are best implemented alongside a real database backend.

---

## 9. Backend Architecture (Rust + Axum)

The backend is built with **Rust** and **Axum** web framework, following a modular architecture pattern.

### 9.1 Tech Stack

*   **Language**: Rust (Edition 2024)
*   **Web Framework**: Axum 0.8
*   **Async Runtime**: Tokio
*   **Database**: PostgreSQL (via SQLx)
*   **Error Handling**: anyhow + thiserror
*   **Logging**: tracing + tracing-subscriber
*   **CORS**: tower-http

### 9.2 Project Structure

```
backend/
├── src/
│   ├── main.rs           # Application entry point, server setup
│   ├── config.rs         # Environment variable configuration
│   ├── error.rs          # Unified error handling (AppError, AppResult)
│   ├── db/
│   │   └── mod.rs        # Database connection pool management
│   ├── models/
│   │   └── mod.rs        # Data models (Event, CreateEventRequest, etc.)
│   ├── handlers/
│   │   ├── mod.rs        # Request handlers
│   │   └── health.rs     # Health check endpoint
│   └── routes/
│       └── mod.rs        # Route definitions
├── Cargo.toml            # Dependencies and project metadata
└── .env.example          # Environment variables template
```

### 9.3 Core Concepts

#### Configuration (`config.rs`)
Environment variables are loaded from `.env` file using `dotenvy`:
*   `DATABASE_URL`: PostgreSQL connection string
*   `PORT`: Server port (default: 3000)
*   `HOST`: Server host (default: 0.0.0.0)
*   `ALLOWED_ORIGINS`: Comma-separated CORS origins (e.g., `http://localhost:4321`)

#### Error Handling (`error.rs`)
Unified error type `AppError` with automatic JSON error responses:
*   `Database(sqlx::Error)`: Database errors
*   `NotFound`: Resource not found (404)
*   `BadRequest(String)`: Invalid request (400)
*   `InternalServer`: Internal server error (500)

#### Database (`db/mod.rs`)
*   Uses SQLx with lazy connection pooling
*   Supports PostgreSQL with async queries
*   Connection pool configuration: max 5 connections

#### Routing (`routes/mod.rs`)
Routes are defined using Axum's routing system:
*   `GET /health`: Health check endpoint
*   `POST /api/events`: Create event (placeholder)

### 9.4 Development Workflow

#### Environment Setup
```bash
# 1. Create .env file
cp .env.example .env

# 2. Configure database URL and CORS
# Edit .env:
# DATABASE_URL=postgres://localhost/agreed_time
# ALLOWED_ORIGINS=http://localhost:4321
```

#### Running the Server
```bash
cd backend
cargo run
# Server starts on http://localhost:3000
```

#### Testing Endpoints
```bash
# Health check
curl http://localhost:3000/health
# Response: {"status":"ok","service":"agreed-time-backend"}
```

### 9.5 Frontend-Backend Integration

#### Development Setup
Two servers must run simultaneously:

**Terminal 1 - Frontend**:
```bash
cd frontend
npm run dev
# Astro dev server: http://localhost:4321
```

**Terminal 2 - Backend**:
```bash
cd backend
cargo run
# Axum API server: http://localhost:3000
```

#### CORS Configuration
The backend is configured to allow requests from the frontend origin:
*   Development: `http://localhost:4321`
*   Production: `https://agreed-time.vercel.app` (configurable via `ALLOWED_ORIGINS`)

#### API Communication
Frontend calls backend APIs using `fetch()`:
```typescript
// Example: frontend/src/services/eventService.ts
const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:3000';

async function createEvent(data) {
  const response = await fetch(`${API_URL}/api/events`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
  return response.json();
}
```

### 9.6 Key Rust Concepts

#### Ownership and Borrowing
*   **Ownership**: Each value has a single owner; when owner goes out of scope, value is dropped
*   **Borrowing**: References (`&T`) allow reading without taking ownership
*   **Mutable Borrowing**: `&mut T` allows modification

#### Error Handling with `?` Operator
```rust
let config = Config::from_env()?;
// If error, immediately returns Err to caller
```

#### Async/Await
```rust
#[tokio::main]
async fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    // .await suspends until operation completes
}
```

#### Iterators (Lazy Evaluation)
```rust
"a,b,c".split(',')           // Creates iterator (lazy)
    .map(|s| s.trim())       // Transform (still lazy)
    .collect::<Vec<_>>()     // Execute and collect
```

### 9.7 Next Steps (Backend)

*   [ ] Implement database schema and migrations
*   [ ] Create event CRUD endpoints
*   [ ] Add authentication/authorization
*   [ ] Implement response submission logic
*   [ ] Add result aggregation queries
*   [ ] Set up automated testing
*   [ ] Configure deployment to VPS

---

## 10. Deployment Strategy

### 10.1 Frontend Deployment
*   **Platform**: Vercel (recommended)
*   **Build Command**: `npm run build`
*   **Output Directory**: `dist/`
*   **Environment Variables**: `PUBLIC_API_URL`

### 10.2 Backend Deployment
*   **Platform**: VPS (self-hosted)
*   **Database**: PostgreSQL on same VPS
*   **CI/CD**: GitHub Actions
    *   Trigger: Push to `main` branch (path: `backend/**`)
    *   Build: Compile Rust binary
    *   Deploy: SSH to VPS, restart systemd service
*   **Environment**: Production `.env` on VPS

### 10.3 Development vs Production

| Environment | Frontend | Backend | Database |
|------------|----------|---------|----------|
| Development | `npm run dev` (localhost:4321) | `cargo run` (localhost:3000) | Local PostgreSQL |
| Production | Vercel CDN | VPS (Rust binary) | PostgreSQL on VPS |