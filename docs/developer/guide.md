# Developer Guide

Welcome to the AgreedTime developer documentation. This guide covers the project architecture, code standards, and contribution workflows.

---

## 1. Architecture & Patterns

This project is built with **Astro** (Static Shell) and **React** (Interactive Islands).

### Core Concept: Astro Islands
We follow the "HTML First" philosophy. The page shell (`Layout`, `Header`, `Text`) is static HTML generated by Astro. Only interactive widgets (like the Form and Calendar) are hydrated as React components using `client:load`.

### File Structure
*   **`src/pages/`**: File-system routing. `new.astro` corresponds to `/new`.
*   **`src/components/`**: React components and Astro snippets.
    *   `CreateEventForm.tsx`: The main "Island" controller.
    *   `TimeGrid.tsx`: Core component for rendering the generic calendar grid structure (weeks, days, time labels).
    *   `TimeSlotCell.tsx`: Renders an individual time slot cell, handling mode-specific (selection/heatmap) visual representation and local interaction.
    *   `TimeSlotSelector.tsx`: Component dedicated to handling time slot selection logic and state, utilizing `TimeGrid` and `TimeSlotCell`.
    *   `Heatmap.tsx`: Component dedicated to handling heatmap data transformation and display logic, utilizing `TimeGrid` and `TimeSlotCell`.
*   **`src/utils/`**: Pure helper functions (e.g., date manipulation using `date-fns`).

### Key Logic: Time Slot Components (TimeGrid, TimeSlotCell, TimeSlotSelector, Heatmap)
The core calendar functionality is now split across several specialized components to reduce redundancy and improve modularity:
*   **`TimeGrid.tsx`**: Provides the structural layout for the calendar grid. It generates rows (days) and columns (time slots) and handles overall grid navigation (e.g., week scrolling). It receives `renderCell` and `renderDateHeader` props to allow parent components to customize cell and header rendering.
*   **`TimeSlotCell.tsx`**: This component renders a single interactive cell within the `TimeGrid`. It encapsulates the mode-specific (selection or heatmap) visual styling, content display (e.g., vote count), tooltips, and local event handling.
*   **`TimeSlotSelector.tsx`**: This component manages the state and logic for selecting time slots. It acts as a wrapper around `TimeGrid`, passing `mode="select"` to `TimeSlotCell` via `TimeGrid`'s `renderCell` prop, and handles drag-to-select interactions. Selected slots are stored as a `Set<string>` of **UTC ISO Strings** (`YYYY-MM-DD_HH:MM-HH:MM`).
*   **`Heatmap.tsx`**: This component handles the data transformation and display of availability heatmaps. It wraps `TimeGrid`, processes raw event response data into `heatmapData`, and passes `mode="heatmap"` to `TimeSlotCell` via `TimeGrid`'s `renderCell` prop. It also calculates minimum/maximum date/time ranges for `TimeGrid`.

---

## 2. Code Style & Standards

### Tech Stack
*   **Framework**: Astro + React 19
*   **Rendering**: SSR (Server-Side Rendering) via `@astrojs/vercel`
*   **Styling**: Tailwind CSS
*   **Notifications**: `react-hot-toast`
*   **Language**: TypeScript (Strict mode)
*   **Date Handling**: `date-fns` (Always use UTC for storage, Local for display)

### Best Practices
*   **Functional Components**: Use React Hooks (`useState`, `useMemo`, `useCallback`).
*   **Props Interface**: Always define a TypeScript interface for component props.
*   **Tailwind**: Use utility classes directly. For complex logic, use conditional strings (template literals).
*   **Accessibility**: Ensure all interactive elements have `role`, `aria-label`, and keyboard support (`onKeyDown`).

---

## 3. Git Commit Convention

We follow the **[Conventional Commits](https://www.conventionalcommits.org/)** specification.

### Format
`type(scope): subject`

### Types
*   `feat`: New feature
*   `fix`: Bug fix
*   `docs`: Documentation only
*   `style`: Formatting (whitespace, semi-colons)
*   `refactor`: Code change that neither fixes a bug nor adds a feature
*   `chore`: Build process, deps, or auxiliary tools

### Example
*   `feat(calendar): add sticky time column`
*   `fix(mobile): resolve long-press selection bug`

---

## 4. Development Workflow

1.  **Start Dev Server**: `npm run dev`
2.  **Build for Production**: `npm run build`
3.  **Preview Build**: `npm run preview`

---

## 5. Event Access and Management Strategy (current implementation)

This section outlines the planned approach for managing access to event pages, balancing ease-of-use with necessary security and privacy considerations, especially before a full user authentication system is in place.

### 5.1 User Flows & Page Roles

*   **Create Event Page (`/new`)**:
    *   Allows users (organizers) to define event details and availability.
    *   On success, backend returns `public_token` (guest link) and `organizer_token` (owner link).
*   **Guest Submission Page (`/event/:public_token`)**:
    *   Accessible via the public invitation link.
    *   Lets attendees submit available time slots and optional comments.
*   **Event Result Page**:
    *   Planned to show aggregated availability/heatmap. Currently the frontend placeholder depends on a real results API (not wired yet).

### 5.2 Access Control (current tokens)

*   **Public token** (`public_token`): used for guest/participant views.
*   **Organizer token** (`organizer_token`): capability URL for owner actions (future manage/finalize flows). There is no secure code at the moment.

### 5.3 User Experience Notes (today)

*   Creation success should show/copy the public link and organizer link; avoid exposing organizer token broadly.
*   Result sharing is expected to be via the public link; a dedicated manage page is not implemented yet.
*   A future “sticky organizer” flag could be stored in LocalStorage (e.g., `agreed_time_admin_${eventId}`) once organizer flows are built.

### 5.4 Future Enhancements

*   Owner dashboard/manage page (finalize/delete) powered by `organizer_token`.
*   Actual results API for aggregation/heatmap and participant list.
*   Optional auth-backed ownership instead of pure capability links.

---

## 6. Frontend UI/UX Details

This section documents the visual and interactive design choices made during development.

### 6.1 Header and Brand Identity

*   **Fixed Header**: A responsive, fixed header (`Layout.astro`) is present across all pages for consistent navigation and branding.
*   **Logo Display**: The `agreed-time-logo.svg` is used as the primary brand identifier.
    *   **Header**: The icon is paired with the text "AgreedTime" (`<span class="font-sans font-bold text-ink">AgreedTime</span>`) to ensure clear brand visibility. The spacing between the icon and text (`gap-0`) is set for a tight, cohesive lockup.
    *   **Favicon**: The `agreed-time-logo.svg` itself is directly used as the favicon, ensuring brand consistency in browser tabs. The redundant `favicon.svg` file has been removed.
    *   **Homepage Hero**: The landing page's hero section prominently displays only the large graphic logo (`agreed-time-logo.svg`) without additional text, maintaining a minimalist and "airy" aesthetic.
*   **Brand Typography**: The primary brand typeface for text elements like "AgreedTime" is set to `font-sans` (Zen Kaku Gothic New) for a modern and digital-native feel, complementing the geometric icon. Serif fonts are used for general headings, and mono fonts for technical/time displays.

### 6.2 Visual Theme (Fujifilm-Inspired Palette)

The application's color palette is carefully crafted to evoke a Fujifilm-inspired aesthetic, characterized by cool, cyanic tones and subtle contrasts.

*   **`frontend/tailwind.config.mjs` Colors**:
    *   `paper`: `#F4F8FA` (Soft, low-saturation blue-grey for main background, reducing visual strain).
    *   `ink`: `#155E75` (Deep cyan-tinted grey for primary text, providing rich contrast).
    *   `film-accent`: `#0891B2` (Vibrant Cyan 600 for primary interactive elements, buttons, selected states).
    *   `film-accent-hover`: `#0E7490` (Darker Cyan 700 for hover states).
    *   `film-border`: `#d4e8ed` (Light, cool grey for borders, matching the logo's outer stroke).
    *   `film-light`: `#FFFFFF` (Pure white for elements like input backgrounds and card interiors, creating layered depth).
*   **Consistency**: All UI components, including `TimeSlotSelector` (selected slot color) and `EventResultView`, now automatically utilize this palette, ensuring a unified visual experience.

### 6.3 Event Result & Organizer Views (current state)

*   **Shared Visualization**: Both the public Result page and the private Organizer Dashboard use the shared `EventResultsDisplay` component to ensure consistency.
*   **Heatmap & Aggregation**: Fully functional. Data is fetched via `eventService.getEventResults` (public) or `eventService.getOrganizerEvent` (admin).
*   **Organizer Dashboard**:
    *   Features a simplified admin control panel (Copy Link, Close Event).
    *   Displays the same heatmap visualization as the public view.
    *   Uses `react-hot-toast` for notifications instead of native alerts.
*   **Share Results**: URL inputs have been simplified to "Copy" buttons with truncated previews for cleaner UI.
*   **Empty State Handling**: Correctly handles cases with no participants, with tailored messages for Organizer vs Guest.

---

## 7. Heatmap Visualization (Implemented)

The Result Page now features a graphical heatmap visualization of participant availability, leveraging the new modular component architecture.

*   **`Heatmap.tsx`**: This is the top-level component for heatmap display. It's responsible for:
    *   Aggregating raw participant responses (from `EventResultView.tsx`) into `heatmapData`.
    *   Calculating the overall minimum/maximum date and time ranges from the available data.
    *   Rendering the `TimeGrid` component, and providing a `renderCell` prop that configures `TimeSlotCell` for `mode="heatmap"`.
*   **`TimeGrid.tsx`**: Provides the underlying calendar grid structure, navigation, and default header rendering.
*   **`TimeSlotCell.tsx`**: In `"heatmap"` mode, it renders each time slot cell with:
    *   A background color intensity based on the ratio of available participants for that slot (`count / totalParticipants`). A non-linear scaling (`Math.pow(ratio, 0.6)`) is applied for smoother and more perceptually distinct gradients.
    *   A numerical display of the `count` of available participants.
    *   A hover tooltip detailing which participants are available for that specific slot.
    *   All interactive selection features (click, drag) are disabled.
*   **Reusability**: By using `TimeGrid` and `TimeSlotCell`, the heatmap visualization benefits from the same robust grid layout and cell-level logic as the `TimeSlotSelector`, ensuring consistency and minimizing code duplication.

---

## 8. Data Layer & Services

To prepare for future backend integration and maintain a clean separation of concerns, all data fetching and manipulation logic has been centralized.

### 8.1 Event Service (`src/services/eventService.ts`)
*   **Purpose**: Central entry for data operations used by components (`EventGuestForm`, `EventResultView`, etc.).
*   **Current behavior**:
    *   `getEvent`, `createEvent`, `submitResponse`, `getEventResults`, `getOrganizerEvent`, `closeEvent` all call real backend APIs. Mocking has been largely removed.

### 8.2 Mock Data Strategy (Deprecated)
*   Mocking has been largely removed as core flows are now backed by the API.

### 8.3 Feature Deferral
*   **Edit/Update**: Features like editing an event or modifying a guest response are intentionally deferred. These require robust authentication and state synchronization that are best implemented alongside a real database backend.

---

## 9. Backend Architecture (Rust + Axum)

The backend is built with **Rust** and **Axum** web framework, following a modular architecture pattern.

### 9.1 Tech Stack

*   **Language**: Rust (Edition 2024)
*   **Web Framework**: Axum 0.8
*   **Async Runtime**: Tokio
*   **Database**: PostgreSQL (via SQLx)
*   **Error Handling**: anyhow + thiserror
*   **Logging**: tracing + tracing-subscriber
*   **CORS**: tower-http

### 9.2 Project Structure

```
backend/
├── src/
│   ├── main.rs           # Application entry point, server setup
│   ├── config.rs         # Environment variable configuration
│   ├── error.rs          # Unified error handling (AppError, AppResult)
│   ├── db/
│   │   └── mod.rs        # Database connection pool management
│   ├── models/
│   │   └── mod.rs        # Data models (Event, CreateEventRequest, etc.)
│   ├── handlers/
│   │   ├── mod.rs        # Request handlers
│   │   ├── health.rs     # Health check endpoint
│   │   └── events.rs     # Event creation/fetch
│   └── routes/
│       └── mod.rs        # Route definitions
├── Cargo.toml            # Dependencies and project metadata
├── Cargo.lock            # Locked dependencies
└── .env (local, not committed) # Environment variables
```

### 9.3 Core Concepts

#### Configuration (`config.rs`)
Environment variables are loaded from `.env` file using `dotenvy`:
*   `DATABASE_URL`: PostgreSQL connection string
*   `PORT`: Server port (default: 3000)
*   `HOST`: Server host (default: 0.0.0.0)
*   `ALLOWED_ORIGINS`: Comma-separated CORS origins (e.g., `http://localhost:4321`)

#### Error Handling (`error.rs`)
Unified error type `AppError` with automatic JSON error responses:
*   `Database(sqlx::Error)`: Database errors
*   `NotFound`: Resource not found (404)
*   `BadRequest(String)`: Invalid request (400)
*   `InternalServer`: Internal server error (500)

#### Database (`db/mod.rs`)
*   Uses SQLx with lazy connection pooling
*   Supports PostgreSQL with async queries
*   Connection pool configuration: max 5 connections

#### Routing (`routes/mod.rs`)
Routes are defined using Axum's routing system:
*   `GET /health`: Health check endpoint
*   `POST /api/events`: Create event
*   `GET /api/events/{public_token}`: Fetch event by public token

### 9.4 Development Workflow

#### Environment Setup
```bash
# Create .env file (manually)
# DATABASE_URL=postgres://localhost/agreed_time
# ALLOWED_ORIGINS=http://localhost:4321
# PORT=3000
# HOST=0.0.0.0
```

#### Running the Server
```bash
cd backend
cargo run
# Server starts on http://localhost:3000
```

#### Testing Endpoints
```bash
# Health check
curl http://localhost:3000/health
# Response: {"status":"ok","service":"agreed-time-backend"}
```

### 9.5 Frontend-Backend Integration

#### Development Setup
Two servers must run simultaneously:

**Terminal 1 - Frontend**:
```bash
cd frontend
npm run dev
# Astro dev server: http://localhost:4321
```

**Terminal 2 - Backend**:
```bash
cd backend
cargo run
# Axum API server: http://localhost:3000
```

#### CORS Configuration
The backend is configured to allow requests from the frontend origin:
*   Development: `http://localhost:4321`
*   Production: `https://agreed-time.vercel.app` (configurable via `ALLOWED_ORIGINS`)

#### API Communication
Frontend calls backend APIs using `fetch()`:
```typescript
// Example: frontend/src/services/eventService.ts
const API_URL = import.meta.env.PUBLIC_API_URL || 'http://localhost:3000';

async function createEvent(data) {
  const response = await fetch(`${API_URL}/api/events`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
  return response.json();
}
```

### 9.6 Key Rust Concepts

#### Ownership and Borrowing
*   **Ownership**: Each value has a single owner; when owner goes out of scope, value is dropped
*   **Borrowing**: References (`&T`) allow reading without taking ownership
*   **Mutable Borrowing**: `&mut T` allows modification

#### Error Handling with `?` Operator
```rust
let config = Config::from_env()?;
// If error, immediately returns Err to caller
```

#### Async/Await
```rust
#[tokio::main]
async fn main() -> Result<()> {
    let listener = TcpListener::bind("0.0.0.0:3000").await?;
    // .await suspends until operation completes
}
```

#### Iterators (Lazy Evaluation)
```rust
"a,b,c".split(',')           // Creates iterator (lazy)
    .map(|s| s.trim())       // Transform (still lazy)
    .collect::<Vec<_>>()     // Execute and collect
```

### 9.7 Next Steps (Backend)

*   [x] Implement database schema and migrations
*   [x] Create event CRUD endpoints (create, get public, get organizer, submit response, get results, close event)
*   [ ] Add authentication/authorization
*   [ ] Set up automated testing
*   [ ] Configure deployment to VPS

---

## 10. Deployment Strategy

### 10.1 Frontend Deployment
*   **Platform**: Vercel (recommended for SSR)
*   **Build Command**: `npm run build`
*   **Output Directory**: `.vercel/output/` (generated by Vercel adapter)
*   **Environment Variables**: `PUBLIC_API_URL`

### 10.2 Backend Deployment
*   **Platform**: VPS (self-hosted)
*   **Database**: PostgreSQL on same VPS
*   **CI/CD**: GitHub Actions
    *   Trigger: Push to `main` branch (path: `backend/**`)
    *   Build: Compile Rust binary
    *   Deploy: SSH to VPS, restart systemd service
*   **Environment**: Production `.env` on VPS

### 10.3 Development vs Production

| Environment | Frontend | Backend | Database |
|------------|----------|---------|----------|
| Development | `npm run dev` (localhost:4321) | `cargo run` (localhost:3000) | Local PostgreSQL |
| Production | Vercel (SSR with adapter) | VPS (Rust binary) | PostgreSQL on VPS |
